using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace ValidationGenerator
{
    [Generator]
    public class ValidationSourceGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // 1. Регистрируем синтаксический провайдер для поиска классов с нашим атрибутом
            var classDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: (s, _) => s is ClassDeclarationSyntax c && c.AttributeLists.Count > 0,
                    transform: (ctx, _) => GetSemanticTargetForGeneration(ctx))
                .Where(m => m is not null);

            // 2. Комбинируем результаты с компиляцией для получения дополнительной информации
            var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

            // 3. Регистрируем действие для генерации кода
            context.RegisterSourceOutput(compilationAndClasses, (spc, source) => Execute(source.Left, source.Right!, spc));
        }

        private ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
        {
            var classDeclaration = (ClassDeclarationSyntax)context.Node;

            // Проверяем наличие нашего маркерного атрибута
            var attribute = classDeclaration.AttributeLists
                .SelectMany(al => al.Attributes)
                .FirstOrDefault(a => a.Name.ToString() == "GenerateValidation");

            return attribute is not null ? classDeclaration : null;
        }

        private void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes, SourceProductionContext context)
        {
            if (classes.IsDefaultOrEmpty) return;

            foreach (var classDeclaration in classes)
            {
                var model = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
                var symbol = model.GetDeclaredSymbol(classDeclaration);

                if (symbol is null) continue;

                // Генерируем код валидатора
                var validatorCode = GenerateValidatorCode(symbol);
                var fileName = $"{symbol.Name}_Validator.g.cs";
                context.AddSource(fileName, SourceText.From(validatorCode, Encoding.UTF8));
            }
        }

        private string GenerateValidatorCode(INamedTypeSymbol classSymbol)
        {
            var className = classSymbol.Name;
            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
            sb.AppendLine($"    public static partial class {className}Validator");
            sb.AppendLine("    {");
            sb.AppendLine($"        public static global::System.Collections.Generic.List<string> Validate({className} instance)");
            sb.AppendLine("        {");
            sb.AppendLine("            var errors = new global::System.Collections.Generic.List<string>();");
            sb.AppendLine();

            // Итерируем по свойствам класса и ищем атрибуты валидации
            foreach (var property in classSymbol.GetMembers().OfType<IPropertySymbol>())
            {
                foreach (var attribute in property.GetAttributes())
                {
                    var attributeClass = attribute.AttributeClass;
                    if (attributeClass is null) continue;

                    // Обработка стандартных атрибутов валидации
                    if (attributeClass.ToDisplayString() == "System.ComponentModel.DataAnnotations.RequiredAttribute")
                    {
                        sb.AppendLine($"            if (instance.{property.Name} == null)");
                        sb.AppendLine($"                errors.Add(\"'{property.Name}' is required.\");");
                    }
                    else if (attributeClass.ToDisplayString() == "System.ComponentModel.DataAnnotations.RangeAttribute")
                    {
                        var min = attribute.ConstructorArguments.FirstOrDefault();
                        var max = attribute.ConstructorArguments.Skip(1).FirstOrDefault();
                        sb.AppendLine($"            if (instance.{property.Name} < {min.Value} || instance.{property.Name} > {max.Value})");
                        sb.AppendLine($"                errors.Add(\"'{property.Name}' must be between {min.Value} and {max.Value}.\");");
                    }
                    // ... можно добавить поддержку других атрибутов (StringLength, RegularExpression и т.д.)
                }
            }

            sb.AppendLine();
            sb.AppendLine("            return errors;");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }
    }
}