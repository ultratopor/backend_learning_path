using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;


namespace FastPropertyAccess.Generator
{
    [Generator]
    public class PropertyAccessSourceGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {

            var methodCalls = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: (s, _) => s is InvocationExpressionSyntax,
                    transform: (ctx, _) => GetInvocationDetails(ctx))
                .Where(m => m is not null);

            var collectedCalls = methodCalls.Collect();

            context.RegisterHostOutput(collectedCalls, GenerateSource);
        }

        private InvocationDetails? GetInvocationDetails(GeneratorSyntaxContext context)
        {
            var invocation = (InvocationExpressionSyntax)context.Node;

            if(invocation.Expression is MemberAccessExpressionSyntax memberAccess &&
                memberAccess.Expression is IdentifierNameSyntax className &&
                className.Identifier.Text == "PropertyCahe")
            {
                var methodSymbol = context.SemanticModel.GetSymbolInfo(invocation).Symbol as IMethodSymbol;

                if (methodSymbol?.Name == "GetGetter" && methodSymbol.IsGenericMethod)
                {
                    var typeArgs = methodSymbol.TypeArguments;
                    var propertyNameArg = invocation.ArgumentList.Arguments.FirstOrDefault()?.Expression;

                    string? propertyName = null;
                    if (propertyNameArg is LiteralExpressionSyntax literal &&
                        literal.IsKind(SyntaxKind.StringLiteralToken))
                    {
                        propertyName = literal.Token.ValueText;
                    }

                    if(typeArgs.Length == 2 && propertyName != null)
                    {
                        return new InvocationDetails(
                            ContainingType: methodSymbol.ContainingType,
                            PropertyType: typeArgs[0],
                            PropertyReturnType: typeArgs[1],
                            PropertyName: propertyName);
                    }
                }
            }
            return null;
        }

        private void GenerateSource(SourceProductionContext context, ImmutableArray<InvocationDetails> invocations)
        {
            if (invocations.IsDefaultOrEmpty)
            {
                return;
            }

            var grouppedInvocations = invocations
                .GroupBy(i => i.PropertyType)
                .ToDictionary(g => g.Key, g => g.ToList());

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();

            var namespaceName = invocations.First().ContainingType.ContainingNamespace.ToDisplayString();
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
            sb.AppendLine("    public static partial class PropertyCache");
            sb.AppendLine("    {");
            sb.AppendLine("         private static readonly System.Collections.Concurrent.ConcurrentDictionary" +
                "<(System.Type Type, string PropertyName), System.Delegate> _precomputedCach = ");
            sb.AppendLine("             new System.Collections.Concurrent.ConcurrentDictionary<(System.Type, " +
                "string PropertyName), System.Gelegate>");
            sb.AppendLine("             {");

            int i = 0;
            foreach (var group in grouppedInvocations)
            {
                var sourceType = group.Key;
                foreach (var invocation in group.Value)
                {
                    sb.AppendLine(
                        $"                  {{(typeof({sourceType.ToDisplayString()}), \"{invocation.PropertyName}\"), " +
                        $"new System.Func<{sourceType.ToDisplayString()}, {invocation.PropertyReturnType.ToDisplayString()}> " +
                        $"(source => source.{invocation.PropertyName}) }}");

                    if(i < grouppedInvocations.Sum(g => g.Value.Count) -1)
                        sb.AppendLine("                  ,");

                    sb.AppendLine();
                    i++;
                }
            }
            sb.AppendLine("             };");
            sb.AppendLine();
            sb.AppendLine("         public static System.Func<T, TProperty> GetGetter<T, TProperty>(string" +
                "propertyName)");
            sb.AppendLine("         {");
            sb.AppendLine("             var key = typeof(T), propertyName);");
            sb.AppendLine("             if(_precomputedCache.TryGetValue(key, out var cachedDelegate))");
            sb.AppendLine("             {");
            sb.AppendLine("                 return (System.Func<T, TProperty>)cachedDelegate;");
            sb.AppendLine("             }");
            sb.AppendLine("            throw new System.InvalidOperationException($\"Геттер для свойства '{propertyName}' типа '{typeof(T).Name}' не был сгенерирован.\");");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");
            context.AddSource("PropertyCache.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private record InvocationDetails(INamedTypeSymbol ContainingType, ITypeSymbol PropertyType, 
                                        ITypeSymbol PropertyReturnType, string PropertyName);
    }
}
