# Теоретический модуль: Неделя 1. Глубокое погружение в CLR и Рефлексию

## Введение: Смена ментальной модели

В Unity вы привыкли использовать GetComponent<T>(). Это форма RTTI (Run-Time Type Information), но она сильно оптимизирована движком (написана на C++). В Enterprise-разработке (ASP.NET Core, Entity Framework) мы работаем с типами данных гораздо агрессивнее. Мы строим системы (валидаторы, мапперы, DI-контейнеры), которые ничего не знают о типах, с которыми работают, до момента запуска приложения.

Ваша задача на этой неделе — понять, как метаданные типов хранятся в памяти и как обращаться к ним эффективно, не убивая производительность сервера.

## Часть 1. Система типов и Метаданные (System.Type)

### 1.1. Method Table и Type Handle

В .NET каждый объект в куче (Heap) имеет заголовок. Этот заголовок содержит указатель на Method Table (MT) этого типа.

Method Table содержит метаданные о типе: какие методы он имеет, кто его родитель, реализуемые интерфейсы.

Когда вы вызываете typeof(MyClass) или obj.GetType(), CLR возвращает объект System.Type, который является оберткой над этими внутренними структурами рантайма.

### 1.2. Рефлексия (System.Reflection)

Рефлексия — это механизм, позволяющий коду инспектировать другой код и взаимодействовать с ним динамически.

**Что мы можем делать:**

- **Инспекция:** Получить список всех свойств, методов, атрибутов класса (Type.GetProperties(), Type.GetMethods()).
- **Динамическое создание:** Создать экземпляр класса, зная только его имя строкой (Activator.CreateInstance()).
- **Динамический вызов:** Прочитать значение приватного поля или вызвать метод, не зная о нем на этапе компиляции (PropertyInfo.GetValue()).

**Пример (аналог того, что будет в задании с Валидатором):**

```csharp
public bool Validate(object obj) 
{
    Type type = obj.GetType();
    
    // Получаем все публичные свойства
    PropertyInfo[] properties = type.GetProperties(); 
    
    foreach (var prop in properties) 
    {
        // ЧИТАЕМ значение свойства динамически (медленно!)
        object value = prop.GetValue(obj);
        
        // Тут будет логика проверки атрибутов...
    }
    return true;
}
```

## Часть 2. Цена Рефлексии (Performance Cost)

В плане указано, что прямой вызов через рефлексию в сотни раз медленнее. Почему?

- **Проверка безопасности и прав доступа:** Каждый раз при вызове GetValue или Invoke CLR проверяет, имеете ли вы право доступа к этому члену (public/private).
- **Boxing (Упаковка):** Метод GetValue возвращает object. Если ваше свойство — это int (struct), оно будет упаковано в куче (allocations!), что создает нагрузку на GC (Garbage Collector).
- **Отсутствие оптимизаций:** JIT-компилятор не может заинлайнить (inline) вызовы через рефлексию.
- **Поиск строк:** Поиск методов по имени (string matching) — дорогая операция.

**Сравнение:**
- obj.Name (прямой доступ): ~1-2 наносекунды.
- propInfo.GetValue(obj): ~500-1000 наносекунд (зависит от типа).

Для Unity это может быть некритично при инициализации сцены, но для сервера, обрабатывающего 10 000 запросов в секунду, использование "голой" рефлексии в горячем пути (Hot Path) — это архитектурная ошибка.

## Часть 3. Атрибуты (Attributes)

Атрибуты в C# — это просто классы, наследуемые от System.Attribute. Они не делают ничего сами по себе. Это пассивные данные (метаданные), "приклеенные" к классам, свойствам или методам.

Чтобы атрибут заработал, нужен внешний механизм (например, ваш класс Validator), который:

- Через рефлексию найдет этот атрибут (prop.GetCustomAttribute<LengthAttribute>()).
- Прочитает его параметры (min, max).
- Выполнит логику.

В задании недели 1 вы будете писать именно этот механизм.

## Часть 4. Оптимизация: Expression Trees (Деревья выражений)

Это ключевая тема для перехода на уровень Senior.

Если рефлексия медленная, как работают быстрые сериализаторы (Newtonsoft, System.Text.Json) или ORM (Dapper, EF Core)? Они используют генерацию кода на лету.

### 4.1. Что такое Expression Tree?

Это представление кода в виде структуры данных (дерева), которое можно анализировать и, главное, компилировать в исполняемый код во время работы программы.

### 4.2. Как это ускоряет код?

Вместо того чтобы каждый раз вызывать медленный GetValue (интерпретация), мы один раз конструируем лямбда-выражение, которое делает то же самое, что и прямой код, компилируем его в делегат и кэшируем.

**Алгоритм оптимизации Валидатора:**

1. **Первый вызов:** Приходит объект типа UserDTO.
2. Мы анализируем его рефлексией (медленно). Находим атрибуты.
3. Мы строим Expression Tree: "Возьми аргумент obj, приведи к UserDTO, прочитай свойство Name".
4. Мы вызываем .Compile(). Это запускает JIT-компилятор и выдает нам быстрый делегат Func<object, bool>.
5. Сохраняем делегат в Dictionary<Type, Func<...>> (Кэш).

**Второй вызов:** Достаем готовый делегат из кэша. Скорость работы почти равна прямому вызову C# кода.

Задача вашего практического задания (Advanced) — реализовать именно этот механизм кэширования логики.

## Часть 5. Дженерики (Generics) и JIT

Unity-разработчики часто используют дженерики (List<T>), но важно понимать разницу между Open Types и Closed Types.

- **List<>** (Open Type) — это шаблон.
- **List<int>** (Closed Type) — это конкретный тип, созданный JIT-компилятором.

**Важно для производительности:** В .NET (в отличие от Java) для каждого Value Type (struct, int, float) генерируется своя копия нативного кода дженерика.

- List<int> и List<float> — это разный код в памяти.
- List<string> и List<object> — делят один код (так как это ссылочные типы).

Понимание этого поможет вам избегать раздувания кода (Code Bloat) при активном использовании дженериков в высоконагруженных системах.