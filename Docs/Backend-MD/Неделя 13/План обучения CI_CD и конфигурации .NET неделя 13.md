# Архитектурная Эволюция: Неделя 13 — CI/CD и Конфигурация .NET

## 1. Введение: Эволюция от ручного развертывания к автоматизированным пайплайнам

Переход квалифицированного Unity-разработчика в сферу Enterprise-бэкенда — это не процесс обучения с нуля, а процесс трансляции существующих глубоких знаний на новый технологический стек. Настоящий отчет представляет собой исчерпывающее руководство, сфокусированное на Фазе III («Frontend-мост») вашего плана обучения, трансформируя недели 11–14 в интенсивный, архитектурно насыщенный пятидневный спринт (20 часов).

Мы не будем изучать синтаксис ради синтаксиса. Мы будем деконструировать архитектурные паттерны React через призму игрового движка Unity, сопоставляя механизмы рендеринга, управления памятью и жизненным циклом объектов. Современный React (версии 18+) с его конкурентным режимом рендеринга (Concurrent Mode) и функциональной парадигмой гораздо ближе к высокопроизводительным игровым системам, чем к классическому MVC веба 2010-х годов.

В основе данного документа лежит анализ фундаментальных различий между Immediate Mode (Unity GUI / IMGUI) и Retained Mode (DOM / React Fiber). Unity-инженер, привыкший к полному контролю над каждым кадром в Update(), должен адаптироваться к реактивной модели, где рендер — это побочный эффект изменения состояния, а не самоцель. Этот сдвиг требует глубокого понимания того, как JavaScript управляет памятью и асинхронностью, в сравнении с .NET CLR и Unity Player Loop.

## 1.1. От ручного развертывания к автоматизированным пайплайнам

Для разработчика, пришедшего из индустрии Unity, процесс развертывания приложения часто сводится к созданию билда в Unity Editor и его загрузке на платформу дистрибуции (Steam, App Store, Google Play). Этот процесс, хотя и может быть автоматизирован через скрипты, по своей природе является дискретным и требует человеческого вмешательства на ключевых этапах.

Тринадцатая неделя призвана решить фундаментальный переход от ручного развертывания к полностью автоматизированным пайплайнам непрерывной интеграции и непрерывного развертывания (CI/CD). Этот переход меняет саму парадигму доставки программного обеспечения: от периодических релизов к непрерывному потоку изменений, автоматически тестируемых и развертываемых в производственную среду.

### 1.2. Стратегические цели модуля

К завершению этой недели инженер должен не просто уметь настраивать GitHub Actions, но и глубоко понимать принципы непрерывной интеграции, стратегии развертывания (Blue-Green, Canary, Rolling), и методы управления конфигурацией в различных средах. В области обеспечения качества задача состоит в том, чтобы освоить автоматизированное тестирование на всех уровнях — от юнит-тестов до интеграционных и энд-то-энд тестов.

## 1.3. Сравнительная таблица парадигм

| Характеристика | Ручное развертывание | Автоматизированный CI/CD | Архитектурное следствие для Недели 13 |
|---|---|---|---|
| Частота релизов | Низкая (раз в недели/месяцы) | Высокая (несколько раз в день) | Требуется автоматизация тестирования и развертывания |
| Риск ошибок | Высокий (человеческий фактор) | Низкий (автоматизация) | Необходимо реализовать откаты (rollbacks) |
| Обратная связь | Медленная (дни/недели) | Быстрая (минуты/часы) | Требуется мониторинг и алертинг |
| Конфигурация | Часто хранится в коде | Внешняя (12-Factor App) | Разделение конфигурации для разных сред |
| Масштабирование | Ручное | Автоматическое | Необходимо реализовать автомасштабирование |

## 2. Стратегия взаимодействия с AI-ментора: Эмуляция Senior DevOps Engineer

Для эффективного освоения материала на 13-й неделе необходимо радикально пересмотреть роль AI-ассистента. Он должен принять персону Senior DevOps Engineer & Release Manager, специализирующегося на CI/CD пайплайнах и управлении конфигурацией в распределенных системах.

### 2.1. Психологический профиль ментора

В отличие от предыдущих недель, где допускались неоптимальные решения, на этой неделе AI должен быть безжалостен к таким аспектам, как отсутствие автоматизации тестирования, неправильное управление секретами или отсутствие стратегий отката. Он должен эмулировать поведение системного архитектора, который блокирует Pull Request, если пайплайн не проходит все проверки или если в коде обнаружены жестко закодированные секреты.

### 2.2. Глобальный системный промт (System Prompt)

```
Роль: Ты — Senior DevOps Engineer и Release Manager с 12-летним опытом работы в высоконагруженных финансовых и телекоммуникационных системах. Ты специализируешься на CI/CD пайплайнах, управлении конфигурацией, автоматизированном тестировании и стратегиях развертывания в Kubernetes и облачных средах.

Контекст: Я — разработчик, находящийся в процессе перехода с Unity на Enterprise Backend (согласно плану обучения). У меня есть рабочий Web API сервис "Календарь" (ASP.NET Core, PostgreSQL, EF Core, RabbitMQ), разработанный на предыдущих этапах. Я понимаю разработку кода, но имею поверхностные знания о CI/CD и автоматизации развертывания.

Твоя задача: Сопровождать меня в процессе создания CI/CD пайплайна для сервиса "Календарь" и настройки управления конфигурацией на 13-й неделе обучения.

Принципы взаимодействия и Критерии качества:

Automation First: При проверке пайплайна ты должен параноидально искать ручные шаги, которые можно автоматизировать. Требуй полного тестирования и развертывания без человеческого вмешательства.
Security Obsession: Критикуй хранение секретов в коде. Требуй использования секретов GitHub, HashiCorp Vault или Azure Key Vault.
Environment Parity: Настаивай на идентичности сред разработки, тестирования и производства. Объясни, почему "it works on my machine" — это проблема конфигурации, а не кода.
Rollback Strategy: Требуй реализации стратегии отката для каждого развертывания. Объясни, почему это критично для производства.
Deep Dive Theory: Не давай просто готовый код. Если я использую GitHub Action, спроси меня, понимаю ли я разницу между github-hosted и self-hosted runners.
Observability Focus: Требуй добавления логирования, метрик и трейсинга на всех этапах пайплайна. Объясни, как настроить алертинг для критических инцидентов.
Формат ответа:
Анализ: Краткая оценка моего решения.
Code Review: Подсветка проблемных зон с объяснением рисков.
Socratic Question: Вопрос на засыпку, заставляющий задуматься об архитектурных последствиях (например: "Что произойдет, если развертывание упадет на полпути? Как система вернется к предыдущему состоянию?").
```

## 3. Детальный план обучения: Погружение в CI/CD и конфигурацию (20 часов)

Программа рассчитана на 5 дней интенсивной работы (по 4 часа в день). Каждый день структурирован следующим образом: теоретический блок (Deep Dive), промпты для исследования (Research Prompts) для самостоятельного изучения с AI, и практическая реализация задач на базе проекта "Календарь".

### День 1: Фундаментальные концепции CI/CD

**Цель:** Понять принципы непрерывной интеграции, непрерывной доставки и непрерывного развертывания.

#### 3.1. Теоретический базис: Под капотом CI/CD

Unity-разработчики привыкли к дискретному процессу разработки: написать код → протестировать → создать билд → опубликовать. CI/CD вводит концепцию непрерывного потока изменений, автоматически проходящих через все этапы от коммита до производства.

**Непрерывная интеграция (Continuous Integration, CI):**

- Практика частого объединения кода нескольких разработчиков в общую ветвь.
- Автоматическая сборка и тестирование каждого коммита.
- Раннее обнаружение интеграционных проблем.

**Непрерывная доставка (Continuous Delivery, CD):**

- Автоматизация процесса доставки кода до среды подготовки к выпуску (staging).
- Код всегда готов к развертыванию в производство.
- Развертывание в производство требует ручного одобрения.

**Непрерывное развертывание (Continuous Deployment):**

- Автоматическое развертывание кода в производство после прохождения всех тестов.
- Полностью автоматизированный процесс от коммита до производства.

#### 3.2. Промпты для исследования (Research Prompts)

Студент должен задать эти вопросы AI-ментору для глубокого погружения:

- "Объясни различия между Git Flow, GitHub Flow и GitLab Flow. В каких случаях каждый из этих подходов предпочтителен для команды разработчиков?"
- "Что такое Trunk-Based Development и как он связан с CI/CD? Почему этот подход рекомендуется для высокопроизводительных команд?"
- "Сравни подходы к ветвлению: Feature Branches vs Feature Flags. В каких случаях каждый подход предпочтителен для непрерывного развертывания?"

#### 3.3. Практическая задача: Настройка базового CI пайплайна

**Задание:** Настроить базовый CI пайплайн в GitHub Actions для сервиса "Календарь".

**Технические требования:**

- Создать файл .github/workflows/ci.yml.
- Настроить триггер на push и pull request в основную ветку.
- Настроить сборку проекта (dotnet build).
- Настроить запуск юнит-тестов (dotnet test).
- Настроить публикацию артефактов сборки.

**Пример .github/workflows/ci.yml:**

```yaml
name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: 8.0.x
        
    - name: Restore dependencies
      run: dotnet restore
      
    - name: Build
      run: dotnet build --no-restore
      
    - name: Test
      run: dotnet test --no-build --verbosity normal
```

### День 2: Интеграционное тестирование в CI

**Цель:** Настроить запуск интеграционных тестов с использованием Testcontainers в CI пайплайне.

#### 4.1. Теоретический базис

Интеграционные тесты требуют реальной инфраструктуры (базы данных, брокеры сообщений) для проверки взаимодействия компонентов. В CI среде эта инфраструктура должна быть автоматически развернута и удалена.

**Testcontainers в CI:**

- Testcontainers позволяет программно управлять Docker-контейнерами.
- В CI среде можно поднять реальные PostgreSQL и RabbitMQ для тестов.
- Обеспечивает максимальную приближенность тестов к производственной среде.

**Параллелизация тестов:**

- Интеграционные тесты могут быть медленными из-за развертывания инфраструктуры.
- Параллельное выполнение тестов может значительно сократить время пайплайна.
- Необходимо обеспечить изоляцию тестов друг от друга.

#### 4.2. Промпты для исследования

- "Как оптимизировать время выполнения интеграционных тестов с Testcontainers в CI? Предложи стратегии кэширования Docker-образов и переиспользования контейнеров."
- "Как обеспечить изоляцию параллельно выполняющихся интеграционных тестов? Опиши подходы к использованию уникальных имен баз данных и очередей для каждого теста."
- "Как интегрировать отчеты о покрытии кода в CI пайплайн? Какие инструменты и сервисы можно использовать для визуализации покрытия?"

#### 4.3. Практическая задача: Интеграционные тесты в CI

**Задание:** Настроить запуск интеграционных тестов с Testcontainers в CI пайплайне.

**Технические требования:**

- Добавить шаг в CI пайплайн для запуска интеграционных тестов.
- Настроить сервис Docker в GitHub Actions для использования Testcontainers.
- Настроить публикацию отчетов о тестировании и покрытии кода.
- Настроить параллельное выполнение тестов для ускорения пайплайна.

**Пример добавления интеграционных тестов в CI:**

```yaml
- name: Integration Tests
  run: |
    docker-compose -f docker-compose.test.yml up -d
    dotnet test --no-build --verbosity normal --logger:"trx;LogFileName=test_results.trx" /p:CollectCoverage=true /p:CoverletOutputFormat=opencover
    docker-compose -f docker-compose.test.yml down
    
- name: Upload Test Results
  uses: actions/upload-artifact@v3
  if: always()
  with:
    name: test-results
    path: TestResults/
```

### День 3: Управление конфигурацией и секретами

**Цель:** Настроить управление конфигурацией для различных сред и безопасное хранение секретов.

#### 5.1. Теоретический базис

В соответствии с методологией 12-Factor App, конфигурация должна храниться отдельно от кода. Это позволяет использовать один и тот же артефакт сборки в разных средах.

**Конфигурация в ASP.NET Core:**

- Иерархия провайдеров конфигурации.
- Переменные окружения как основной источник конфигурации в production.
- Секреты User Secrets для локальной разработки.

**Управление секретами:**

- Никогда не хранить секреты в коде или системе контроля версий.
- Использование секретов GitHub, Azure Key Vault или HashiCorp Vault.
- Доступ к секретам только в CI/CD пайплайне.

#### 5.2. Промпты для исследования

- "Сравни подходы к управлению секретами: GitHub Secrets vs Azure Key Vault vs HashiCorp Vault. В каких случаях каждый подход предпочтителен?"
- "Как реализовать ротацию секретов в production среде? Опиши стратегии автоматической ротации паролей базы данных и ключей API."
- "Объясни концепцию Configuration as Code. Какие инструменты (Terraform, Ansible, Pulumi) можно использовать для управления конфигурацией инфраструктуры?"

#### 5.3. Практическая задача: Управление конфигурацией

**Задание:** Настроить управление конфигурацией для различных сред и безопасное хранение секретов.

**Технические требования:**

- Создать файлы конфигурации для разных сред (appsettings.Development.json, appsettings.Staging.json, appsettings.Production.json).
- Настроить переменные окружения для каждой среды.
- Настроить секреты в GitHub для хранения чувствительных данных.
- Реализовать механизм загрузки конфигурации из внешних источников (например, Azure App Configuration).

### День 4: Стратегии развертывания

**Цель:** Изучить и реализовать различные стратегии развертывания: Blue-Green, Canary, Rolling.

#### 6.1. Теоретический базис

Выбор стратегии развертывания зависит от требований к доступности, рисков и сложности отката.

**Blue-Green Deployment:**

- Поддерживаются две идентичные среды: Blue (текущая) и Green (новая).
- Переключение трафика с Blue на Green мгновенно.
- Легкий откат путем переключения трафика обратно.

**Canary Deployment:**

- Новая версия развертывается для небольшой части пользователей.
- Постепенное увеличение трафика на новую версию.
- Минимальное влияние в случае проблем.

**Rolling Deployment:**

- Постепенная замена старых экземпляров новыми.
- Нет простоя в процессе развертывания.
- Сложный откат в случае проблем.

#### 6.2. Промпты для исследования

- "Сравни стратегии развертывания: Blue-Green vs Canary vs Rolling. В каких случаях каждая стратегия предпочтительна для веб-приложений?"
- "Как реализовать автоматическое переключение трафика на основе метрик производительности в Canary развертывании? Какие инструменты можно использовать для этого?"
- "Объясни концепцию Feature Flags и как они могут быть использованы для управления выпуском функциональности в production."

#### 6.3. Практическая задача: Реализация стратегии развертывания

**Задание:** Реализовать стратегию Blue-Green развертывания для сервиса "Календарь".

**Технические требования:**

- Настроить две среды развертывания (blue и green).
- Реализовать механизм переключения трафика между средами.
- Настроить автоматические тесты на новой среде перед переключением трафика.
- Реализовать автоматический откат в случае провала тестов.

### День 5: Мониторинг и наблюдаемость

**Цель:** Настроить мониторинг, логирование и трейсинг для сервиса "Календарь".

#### 7.1. Теоретический базис

Наблюдаемость (Observability) — это способность измерять внутреннее состояние системы на основе внешних данных. Она включает три столпа: логи, метрики и трейсы.

**Логирование:**

- Структурированные логи для автоматической обработки.
- Уровни логирования (Debug, Information, Warning, Error, Critical).
- Централизованное хранение и анализ логов.

**Метрики:**

- Количественные показатели производительности и использования ресурсов.
- Сбор метрик с помощью Prometheus и визуализация в Grafana.
- Алертинг на основе метрик.

**Трейсинг:**

- Отслеживание запроса через распределенную систему.
- OpenTelemetry как стандарт для трейсинга.
- Корреляция логов, метрик и трейсов.

#### 7.2. Промпты для исследования

- "Сравни подходы к логированию: структурированное vs неструктурированное. Почему структурированное логирование предпочтительнее для автоматического анализа?"
- "Как настроить сбор метрик .NET приложения с помощью Prometheus? Какие метрики критически важны для мониторинга здоровья веб-сервиса?"
- "Объясни концепцию Distributed Tracing. Как OpenTelemetry помогает отслеживать запросы через распределенную систему?"

#### 7.3. Практическая задача: Настройка наблюдаемости

**Задание:** Настроить мониторинг, логирование и трейсинг для сервиса "Календарь".

**Технические требования:**

- Настроить структурированное логирование в приложении.
- Настроить сбор метрик с помощью Prometheus.
- Настроить дашборд в Grafana для визуализации метрик.
- Настроить трейсинг с помощью OpenTelemetry.
- Настроить алертинг для критических метрик.

## 4. Глубокий анализ инсайтов и связей (Second-Order Insights)

Интеграция материалов недели 13 с общим контекстом документа позволяет выявить неочевидные, но критические взаимосвязи.

### 4.1. Связь с управлением памятью (Неделя 2)

На второй неделе изучались SOH/LOH и сборка мусора. В контексте CI/CD это знание обретает новый смысл.

**Инсайт:** Автоматизированные тесты производительности должны включать мониторинг метрик GC. Регрессии в управлении памятью могут быть обнаружены на ранних этапах CI/CD пайплайна.

**Следствие:** Необходимо включить в CI/CD пайплайн тесты производительности, которые отслеживают метрики GC и предупреждают об их деградации.

### 4.2. Связь с многопоточностью (Неделя 3)

На третьей неделе изучались потоки и пул потоков. В контексте CI/CD это знание критически важно.

**Инсайт:** Нагрузочное тестирование должно быть частью CI/CD пайплайна для проверки поведения приложения под нагрузкой.

**Следствие:** Необходимо включить в CI/CD пайплайн нагрузочные тесты, которые проверяют поведение приложения под высокой нагрузкой и выявляют проблемы с многопоточностью.

### 4.3. Связь с будущей темой безопасности (Неделя 14)

CI/CD является фундаментом для внедрения практик безопасности (DevSecOps).

**Инсайт:** Автоматизированное сканирование безопасности должно быть интегрировано в CI/CD пайплайн для раннего обнаружения уязвимостей.

**Следствие:** Необходимо включить в CI/CD пайплайн сканеры безопасности (SAST, DAST, SCA) для анализа кода и зависимостей на наличие уязвимостей.

## 5. Заключение

Тринадцатая неделя является критически важной точкой в программе обучения. Студент переходит от ручного развертывания к полностью автоматизированным пайплайнам CI/CD, что открывает путь к построению действительно надежных и масштабируемых систем доставки программного обеспечения. Владение CI/CD и понимание принципов непрерывной интеграции и доставки — это тот навык, который отличает Senior разработчика от Middle в области Enterprise-систем. Этот навык обеспечивает фундамент для построения сложных микросервисных архитектур, способных выдерживать нагрузки Enterprise-уровня, к которым готовит данный курс.

## Источники

1. Разработка бэкенда: план обучения C#